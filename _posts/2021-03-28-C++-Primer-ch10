---
layout: post
title: C++ Primer 第十章 泛型算法
description: C++ Primer 第六章 泛型算法
category: [C++,C++ Primer]
---
**泛型算法**：称为“算法”，是因为他们实现了一下经典算法的公共接口；称为“泛型”是因为它们可以用于不同类型的元素和多种容器类型，以及用于其他类型的序列  

迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。虽然迭代器的使用不依赖于容器类型，但大多数算法都使用了一个或是多个类型上的操作。
**算法永远不会执行容器的操作**，他们只会运行于迭代器之上，执行迭代器的操作
## 10.2 初识泛型算法
除了少数例外，标准库算法都对一个范围内的元素进行操作
### 只读算法
一些算法只会读取其输入范围内的元素而不改变元素。如`find`和`count`函数。另一个只读函数是`accumulate`，存在于`<numeric>`  
```
// 对vec内的元素求和，和的初值为0
int sum = accumulate(vec.cbegin(), vec.cend(), 0);
```
`accumulate`这里蕴含着编程假定：序列中的元素类型必须与第三个参数匹配。  
另一个只读算法是`equal`，用于确定两个序列是否保存相同的值  
```
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```
由于equal只利用迭代器，所以元素类型也可以不一样，只要能用`==`比较元素类型即可，如string和char*。
equal基于一个非常重要的假设：它假定第二个序列之上与第一个序列一样长。
### 写容器的算法
算法不会执行容器操作，因此他们自身不会改变容器的大小，**算法不检查写操作**，所以需要特别小心，不要向容器范围外写入。
## 10.3 定制操作

